#pragma once

#include <ctime>
#include <map>
#include <string>
#include "server.hpp"
#include <cstring>
#include <sstream>
// request class generated by ai for testing purposes
class Request {
    private:
        std::string method;
        std::string path;
        std::string version;
        std::string body;
        std::map<std::string, std::string> headers;
        std::map<std::string, std::string> queryParams;
    
    public:
        Request()
            : method("GET"), path("/api/v1/script.py"), version("HTTP/1.1"), body("") {}
    
        // Getters
        std::string getMethod() const { return method; }
        std::string getPath() const { return path; }
        std::string getVersion() const { return version; }
        std::string getBody() const { return body; }
        std::map<std::string, std::string> &getHeaders()  { return headers; }
        std::map<std::string, std::string> getQueryParams() const { return queryParams; }
    
        // Setters for mocking purposes
        void setMethod(const std::string& m) { method = m; }
        void setPath(const std::string& p) { path = p; }
        void setVersion(const std::string& v) { version = v; }
        void setBody(const std::string& b) { body = b; }
        void setHeaders(const std::map<std::string, std::string>& h) { headers = h; }
        void setQueryParams(const std::map<std::string, std::string>& q) { queryParams = q; }
    
        std::string getHeader(const std::string& key) const {
            std::map<std::string, std::string>::const_iterator it = headers.find(key);
            if (it != headers.end()) return it->second;
            return "";
        }
    };

    class Cgi {
        private:
            std::time_t start;
            std::vector<char*> envp;
            std::map<std::string, std::string> extension_table;
            Route& route;
            Request& request;
            std::string output;
            std::string input;
            int childPid;
            
            std::string binaryPath;
        public:

            Cgi(Route &route, Request &req);
            Cgi(const Cgi& other);
            ~Cgi();
            Cgi& operator=(const Cgi& other);
            Cgi(Cgi &other);
            void execute();
            void env_set_up();
            std::string getResponse();
            class CGIException : public std::exception
            {
                std::string reason;
                public :
                CGIException(std::string reason) : reason(reason){};
                const char *what() const throw() 
                {
                    return this->reason.c_str();
                }
            };
        };
        